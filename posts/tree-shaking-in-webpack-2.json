{
  "title": "Tree-Shaking ES6 Modules in webpack 2",
  "date": "2017-01-16T00:00:00.000Z",
  "bodyContent": "Webpack 2 is still in its beta stage at the time of writing this, but should see its release very soon. It brings with it a variety of anticipated features. One of those features includes native support for ES6 modules.\n\n#### So what? \n\nSo instead of using the `var module = require('module')` syntax, webpack 2 supports ES6 `imports` and `exports`. This proves quite powerful, and opens the door for some code optimizations such as **tree-shaking**.\n\n## What is tree-shaking?\n\nPopularized by Rich Harris' [Rollup.js](http://rollupjs.org/) module bundler, *tree-shaking* is the ability to only include code in your bundle that is being *used.* When I first played around with Rollup, I was amazed at how well it worked with ES6 modules. The development experience just felt...right. I can create separate modules written in \"future JavaScript\", and then include them anywhere in my code. Any code that goes unused doesn't make it into my bundle. Genius! \n\n#### What problem does it solve? \n\nIf you're writing JavaScript in 2017 and *understand* (see: [JavaScript fatigue](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.nk6chuvta)) the various tools around, your development experience probably feels pretty fluid. This is important, but what's also important is *user experience*. A lot of this modern tooling ends up bloating web applications with massive JavaScript files, resulting in performance loss.\n\nWhat I love about Harris' Rollup is that it takes a stab at this issue and brings a solution to the forefront of the JavaScript community. Now big names like webpack are attempting to iterate on it. \n\n#### A simple example\n\nBefore we get started I want to provide you with a trivial example of tree-shaking. Our application is made up of 2 files, `index.js` and `module.js`. \n\nInside of `module.js` we export 2 named arrow functions:\n\n```\n// module.js\nexport const sayHello = name => `Hello ${name}!`;\n\nexport const sayBye = name => `Bye ${name}!`;\n```\n\nOnly `sayHello` is imported into `index.js` file:\n\n```\n// index.js\nimport { sayHello } from './module';\n\nsayHello('World');\n```\n\n`sayBye` is exported but *never* imported. Anywhere. Therefore, due to tree-shaking, it won't be included in our bundle:\n\n```\n// bundle.js\nconst sayHello = name => `Hello ${name}!`;\n\nsayHello('World');\n```\n\nDepending on the bundler used, the output file above may look different. It's just a simplified version, but you get the idea!\n\nRecently I read an article written by [Roman Liutikov](https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf#.69aadkgrb), and he made a great analogy in order to visualize the concept of tree-shaking:\n\n> If you wonder why it’s called tree-shaking: think of your application as a dependency graph, this is a tree, and each export is a branch. So if you shake the tree, the dead branches will fall. \n\n## Tree-shaking in webpack 2\n\nUnfortunately for those of us using webpack, tree-shaking is \"behind a switch\", if you will. Unlike Rollup, some configuration needs to be done before we can get the functionality we're looking for. The \"behind a switch\" part might confuse some people. I'll explain.\n\n#### Step 1: Project setup\n\nI'm going to assume that you understand webpack basics and can find your way around a basic webpack configuration file. Let's start by creating a new directory:\n\n```\nmkdir webpack-tree-shaking && cd webpack-tree-shaking\n```\n\nOnce inside, let's initialize a new `npm` project:\n\n```\nnpm init -y\n```\n\nThe `-y` option generates the `package.json` quickly without requiring you to answer a bunch of questions. \n\nNext, let's install a few project dependencies:\n\n```\nnpm i --save-dev webpack@beta html-webpack-plugin\n```\n\nThe command above will install the latest beta version of webpack 2 locally in our project as well as a useful plugin named `html-webpack-plugin`. The latter is not necessary for the goal of this walkthrough but will make things a bit quicker.\n\nOpen up `package.json` and make sure they've been installed as `devDependencies`.\n\n#### Step 2: Create JS files\n\nIn order to see tree-shaking in action we need to have some JavaScript to play around with. In your project's root, create a `src` folder with 2 files inside:\n\n```\nmkdir src && cd src\n\ntouch index.js\n\ntouch module.js\n\n```\n\nCopy the code below into the correct files:\n\n```\n// module.js\nexport const sayHello = name => `Hello ${name}!`;\n\nexport const sayBye = name => `Bye ${name}!`;\n```\n\n```\n// index.js\nimport { sayHello } from './module';\n\nconst element = document.createElement('h1');\n\nelement.innerHTML = sayHello('World');\n\ndocument.body.appendChild(element);\n```\n\nIf you've gotten this far, your folder structure should look like this:\n\n```\n/\n| - node_modules/\n| - src/\n|   | - index.js\n|   | - module.js\n| - package.json\n```\n\n#### Step 3: Webpack from the CLI\n\nSince we have no configuration file created for our project, the only way to get webpack to do any work at the moment is through the webpack CLI. Let's perform a quick test. \n\nIn your terminal, run the following command in your project's root:\n\n```\nnode_modules/.bin/webpack\n```\n\nAfter running this command, you should see output like this:\n\n```\nNo configuration file found and no output filename configured via CLI option. \nA configuration file could be named 'webpack.config.js' in the current directory. \nUse --help to display the CLI options.\n```\n\nThe command doesn't do anything, and the webpack CLI confirms this. We haven't given webpack any information about what files we want to bundle up. We could provide this information via the command line *or* a configuration file. Let's choose the former just to test that everything is working:\n\n```\nnode_modules/.bin/webpack src/index.js dist/bundle.js\n```\n\nWhat we've done now is pass webpack an `entry` file and an `output` file via the CLI. This information tells webpack, \"go to `src/index.js` and bundle up all the necessary code into `dist/bundle.js`\". And it does just that. You'll notice that you now have a `dist` directory containing `bundle.js`.\n\nOpen it up and check it out. There's some extra javascript in the bundle necessary for webpack to do its thing, but at the bottom of the file you should see your own code as well. \n\n#### Step 4: Create a webpack configuration file\n\nWebpack can handle a lot of things. I've spent a good chunk of my free time diving into this bundler and I still have barely scratched the surface. Once you've move passed trivial examples its best to leave the CLI behind and create a configuration file to handle the heavy lifting. \n\nIn your project's root, create a `webpack.config.js` file:\n\n```\ntouch webpack.config.js\n```\n\nThis file can be as complicated as you make it. We'll keep it light for the sake of this post:\n\n```\n// webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js',\n    path: 'dist'\n  },\n  plugins: [\n    new HtmlWebpackPlugin({ title: 'Tree-shaking' })\n  ]\n}\n```\n\nThis file provides webpack with the same information we gave to the CLI earlier. We've defined `index.js` as our `entry` file and `bundle.js` as our `output` file. We've also added our `html-webpack-plugin` which will generate an html file in our `dist` directory. Convenient.\n\nGo ahead and test this to make sure it's still working. Remove your `dist` directory, and in the command line type:\n\n```\nwebpack\n```\n\nIf everything went smoothly, you can open up `dist/index.html` and see \"Hello World!\".\n\n==**Note:** The use of a configuration file gives us the convenience of typing `webpack` instead of `node_modules/.bin/webpack`. Small wins.==\n\n#### Step 5: Babel\n\nI mentioned earlier that webpack 2 brings native support for ES6 modules. This is all true, but it doesn't change the fact that ES6 is not fully supported across all browsers. Because of this, we're required to *transform* our ES6 code into readily acceptable JavaScript using a tool like [Babel](http://babeljs.io/). In conjunction with webpack, Babel gives us the ability to write our \"future JavaScript\" without worrying about the implications of unsupported browsers.\n\nLet's go ahead and install Babel in our project:\n\n```\nnpm i --save-dev babel-core babel-loader babel-preset-es2015\n```\n\nTake note of the `babel-preset-es2015` package. This little guy is the reason I sat down to write all of this up.\n\n#### Step 6: `babel-loader`\n\nWebpack can be configured to transform specific files into modules via [loaders](https://webpack.js.org/concepts/#loaders). Once they are transformed, they are added to a dependency graph. Webpack uses the graph to resolve dependencies and includes only what is needed into the final bundle. This is the basis for how webpack works. \n\nWe can now configure webpack to use `babel-loader` to transform all of our `.js` files:\n\n```\n// webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: { filename: 'bundle.js', path: 'dist' },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n        options: { \n          presets: [ \n            'es2015' \n          ] \n        }\n      }\n    ]\n  },\n  plugins: [ \n    new HtmlWebpackPlugin({ title: 'Tree-shaking' }) \n  ]\n};\n```\n\nThe `module` property provides a set of instructions for webpack. It says, \"take any files ending in `.js` and transform them using `babel-loader`, but don't transform any files inside of `node_modules`!\" \n\nWe're also passing the `babel-preset-es2015` package as an option to `babel-loader`. This just tells `babel-loader` *how* to transform the JavaScript.\n\nRun `webpack` again to make sure everything is good. Yes? Great! What we've done is bundled up our JavaScript files while compiling them down to JavaScript thats readily supported across browsers. \n\n\n## The underlying problem\n\nThe package `babel-preset-es2015` contains another package named `babel-plugin-transform-es2015-modules-commonjs` that turns all of our ES6 modules into `CommonJS` modules. This isn't ideal, and here's why.\n\nJavascript bundlers such as webpack and Rollup can only perform tree-shaking on modules that have a static structure. If a module is static, then the bundler can determine its structure at build time, safely removing code that isn't being imported anywhere. \n\n`CommonJS` modules do not have a static structure. Because of this, webpack won’t be able to tree-shake unused code from the final bundle. Luckily, Babel has alleviated this issue by providing developers with an option that we can pass to our `presets` array along with `babel-preset-es2015`:\n\n```\noptions: { \n  presets: [ \n    [ 'es2015', { modules: false } ] \n  ]         \n}\n```\n\nAccording to Babel's [documentation](https://github.com/babel/babel/tree/master/packages/babel-preset-es2015#options): \n\n*\"`modules` - Enable transformation of ES6 module syntax to another module type (Enabled by default to \"commonjs\").\nCan be `false` to not transform modules, or one of `[\"amd\", \"umd\", \"systemjs\", \"commonjs\"]`\"*.\n\nSlide that extra bit of code into your configuration and you'll be cooking with peanut oil.\n\nThe final state of `webpack.config.js` looks like this:\n\n```\n// webpack.config.js\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: { filename: 'bundle.js', path: 'dist' },\n  module: {\n    rules: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: 'babel-loader',\n        options: { \n          presets: [ \n            [ 'es2015', { modules: false } ] \n          ] \n        }\n      }\n    ]\n  },\n  plugins: [ new HtmlWebpackPlugin({ title: 'Tree-shaking' }) ]\n};\n\n```\n\n## The Grand Finale\nRun `webpack` again and pop open your `bundle.js` file. You won't notice any difference. Before you go crazy, know this! It's ok. We've been running webpack in development mode this whole time. Webpack knows that we have unused exports in our code. Even though it's included in the final bundle, `sayBye` will never make it to production. \n\nIf you still don't believe me, run `webpack -p` in your terminal. The `-p` option stands for *production*. Webpack will perform a few extra performance optimizations, including minification, removing any unused code along the way. \n\nOpen up `bundle.js`. Since it's minified, go ahead and search for `Hello`. It *should* be there. Search for `Bye`. It *shouldn't*. \n\nVoila! We now have a working implementation of tree-shaking in webpack 2!\n\nFor the curious, I've been slowly iterating over my own lightweight webpack configuration in a [GitHub Repo](https://github.com/jake-wies/webpack-hotplate). It's not meant to be overly verbose and bloated. It's focused on being an approachable boilerplate with walkthroughs at every turn. If you're interested, check it out!",
  "bodyHtml": "<p>Webpack 2 is still in its beta stage at the time of writing this, but should see its release very soon. It brings with it a variety of anticipated features. One of those features includes native support for ES6 modules.</p>\n<h4 id=\"so-what-\">So what?</h4>\n<p>So instead of using the <code>var module = require(&#39;module&#39;)</code> syntax, webpack 2 supports ES6 <code>imports</code> and <code>exports</code>. This proves quite powerful, and opens the door for some code optimizations such as <strong>tree-shaking</strong>.</p>\n<h2 id=\"what-is-tree-shaking-\">What is tree-shaking?</h2>\n<p>Popularized by Rich Harris&#39; <a href=\"http://rollupjs.org/\">Rollup.js</a> module bundler, <em>tree-shaking</em> is the ability to only include code in your bundle that is being <em>used.</em> When I first played around with Rollup, I was amazed at how well it worked with ES6 modules. The development experience just felt...right. I can create separate modules written in &quot;future JavaScript&quot;, and then include them anywhere in my code. Any code that goes unused doesn&#39;t make it into my bundle. Genius! </p>\n<h4 id=\"what-problem-does-it-solve-\">What problem does it solve?</h4>\n<p>If you&#39;re writing JavaScript in 2017 and <em>understand</em> (see: <a href=\"https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.nk6chuvta\">JavaScript fatigue</a>) the various tools around, your development experience probably feels pretty fluid. This is important, but what&#39;s also important is <em>user experience</em>. A lot of this modern tooling ends up bloating web applications with massive JavaScript files, resulting in performance loss.</p>\n<p>What I love about Harris&#39; Rollup is that it takes a stab at this issue and brings a solution to the forefront of the JavaScript community. Now big names like webpack are attempting to iterate on it. </p>\n<h4 id=\"a-simple-example\">A simple example</h4>\n<p>Before we get started I want to provide you with a trivial example of tree-shaking. Our application is made up of 2 files, <code>index.js</code> and <code>module.js</code>. </p>\n<p>Inside of <code>module.js</code> we export 2 named arrow functions:</p>\n<pre><code><span class=\"hljs-comment\">// module.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>!`</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sayBye = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Bye <span class=\"hljs-subst\">${name}</span>!`</span>;\n</code></pre><p>Only <code>sayHello</code> is imported into <code>index.js</code> file:</p>\n<pre><code><span class=\"hljs-comment\">// index.js</span>\n<span class=\"hljs-keyword\">import</span> { sayHello } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module'</span>;\n\nsayHello(<span class=\"hljs-string\">'World'</span>);\n</code></pre><p><code>sayBye</code> is exported but <em>never</em> imported. Anywhere. Therefore, due to tree-shaking, it won&#39;t be included in our bundle:</p>\n<pre><code><span class=\"hljs-comment\">// bundle.js</span>\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>!`</span>;\n\nsayHello(<span class=\"hljs-string\">'World'</span>);\n</code></pre><p>Depending on the bundler used, the output file above may look different. It&#39;s just a simplified version, but you get the idea!</p>\n<p>Recently I read an article written by <a href=\"https://medium.com/@roman01la/dead-code-elimination-and-tree-shaking-in-javascript-build-systems-fb8512c86edf#.69aadkgrb\">Roman Liutikov</a>, and he made a great analogy in order to visualize the concept of tree-shaking:</p>\n<blockquote>\n<p>If you wonder why it’s called tree-shaking: think of your application as a dependency graph, this is a tree, and each export is a branch. So if you shake the tree, the dead branches will fall. </p>\n</blockquote>\n<h2 id=\"tree-shaking-in-webpack-2\">Tree-shaking in webpack 2</h2>\n<p>Unfortunately for those of us using webpack, tree-shaking is &quot;behind a switch&quot;, if you will. Unlike Rollup, some configuration needs to be done before we can get the functionality we&#39;re looking for. The &quot;behind a switch&quot; part might confuse some people. I&#39;ll explain.</p>\n<h4 id=\"step-1-project-setup\">Step 1: Project setup</h4>\n<p>I&#39;m going to assume that you understand webpack basics and can find your way around a basic webpack configuration file. Let&#39;s start by creating a new directory:</p>\n<pre><code><span class=\"hljs-built_in\">mkdir</span> webpack-<span class=\"hljs-built_in\">tree</span>-shaking &amp;&amp; <span class=\"hljs-built_in\">cd</span> webpack-<span class=\"hljs-built_in\">tree</span>-shaking\n</code></pre><p>Once inside, let&#39;s initialize a new <code>npm</code> project:</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> init -y\n</code></pre><p>The <code>-y</code> option generates the <code>package.json</code> quickly without requiring you to answer a bunch of questions. </p>\n<p>Next, let&#39;s install a few project dependencies:</p>\n<pre><code><span class=\"hljs-built_in\">npm</span> i --save-dev webpack@beta html-webpack-plugin\n</code></pre><p>The command above will install the latest beta version of webpack 2 locally in our project as well as a useful plugin named <code>html-webpack-plugin</code>. The latter is not necessary for the goal of this walkthrough but will make things a bit quicker.</p>\n<p>Open up <code>package.json</code> and make sure they&#39;ve been installed as <code>devDependencies</code>.</p>\n<h4 id=\"step-2-create-js-files\">Step 2: Create JS files</h4>\n<p>In order to see tree-shaking in action we need to have some JavaScript to play around with. In your project&#39;s root, create a <code>src</code> folder with 2 files inside:</p>\n<pre><code>mkdir src &amp;&amp; cd src\n\n<span class=\"hljs-keyword\">touch</span> <span class=\"hljs-built_in\">index</span>.js\n\n<span class=\"hljs-keyword\">touch</span> <span class=\"hljs-keyword\">module</span>.js\n</code></pre><p>Copy the code below into the correct files:</p>\n<pre><code><span class=\"hljs-comment\">// module.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>!`</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> sayBye = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =&gt;</span> <span class=\"hljs-string\">`Bye <span class=\"hljs-subst\">${name}</span>!`</span>;\n</code></pre><pre><code><span class=\"hljs-comment\">// index.js</span>\n<span class=\"hljs-keyword\">import</span> { sayHello } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./module'</span>;\n\n<span class=\"hljs-keyword\">const</span> element = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'h1'</span>);\n\nelement.innerHTML = sayHello(<span class=\"hljs-string\">'World'</span>);\n\n<span class=\"hljs-built_in\">document</span>.body.appendChild(element);\n</code></pre><p>If you&#39;ve gotten this far, your folder structure should look like this:</p>\n<pre><code>/\n|<span class=\"hljs-string\"> - node_modules/\n</span>|<span class=\"hljs-string\"> - src/\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\"> - index.js\n</span>|<span class=\"hljs-string\">   </span>|<span class=\"hljs-string\"> - module.js\n</span>|<span class=\"hljs-string\"> - package.json</span>\n</code></pre><h4 id=\"step-3-webpack-from-the-cli\">Step 3: Webpack from the CLI</h4>\n<p>Since we have no configuration file created for our project, the only way to get webpack to do any work at the moment is through the webpack CLI. Let&#39;s perform a quick test. </p>\n<p>In your terminal, run the following command in your project&#39;s root:</p>\n<pre><code>node_modules<span class=\"hljs-regexp\">/.bin/</span>webpack\n</code></pre><p>After running this command, you should see output like this:</p>\n<pre><code><span class=\"hljs-keyword\">No</span> configuration <span class=\"hljs-keyword\">file</span> found and <span class=\"hljs-keyword\">no</span> output filename configured via <span class=\"hljs-keyword\">CLI</span> option. \nA configuration <span class=\"hljs-keyword\">file</span> could be named 'webpack.config.js' <span class=\"hljs-keyword\">in</span> the current directory. \n<span class=\"hljs-keyword\">Use</span> --<span class=\"hljs-keyword\">help</span> to <span class=\"hljs-keyword\">display</span> the <span class=\"hljs-keyword\">CLI</span> options.\n</code></pre><p>The command doesn&#39;t do anything, and the webpack CLI confirms this. We haven&#39;t given webpack any information about what files we want to bundle up. We could provide this information via the command line <em>or</em> a configuration file. Let&#39;s choose the former just to test that everything is working:</p>\n<pre><code>node_modules<span class=\"hljs-regexp\">/.bin/</span>webpack src<span class=\"hljs-regexp\">/index.js dist/</span>bundle.js\n</code></pre><p>What we&#39;ve done now is pass webpack an <code>entry</code> file and an <code>output</code> file via the CLI. This information tells webpack, &quot;go to <code>src/index.js</code> and bundle up all the necessary code into <code>dist/bundle.js</code>&quot;. And it does just that. You&#39;ll notice that you now have a <code>dist</code> directory containing <code>bundle.js</code>.</p>\n<p>Open it up and check it out. There&#39;s some extra javascript in the bundle necessary for webpack to do its thing, but at the bottom of the file you should see your own code as well. </p>\n<h4 id=\"step-4-create-a-webpack-configuration-file\">Step 4: Create a webpack configuration file</h4>\n<p>Webpack can handle a lot of things. I&#39;ve spent a good chunk of my free time diving into this bundler and I still have barely scratched the surface. Once you&#39;ve move passed trivial examples its best to leave the CLI behind and create a configuration file to handle the heavy lifting. </p>\n<p>In your project&#39;s root, create a <code>webpack.config.js</code> file:</p>\n<pre><code>touch webpack<span class=\"hljs-selector-class\">.config</span><span class=\"hljs-selector-class\">.js</span>\n</code></pre><p>This file can be as complicated as you make it. We&#39;ll keep it light for the sake of this post:</p>\n<pre><code><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = require(<span class=\"hljs-string\">'html-webpack-plugin'</span>);\n\n<span class=\"hljs-keyword\">module</span>.<span class=\"hljs-keyword\">exports</span> = {\n  entry: <span class=\"hljs-string\">'./src/index.js'</span>,\n  output: {\n    filename: <span class=\"hljs-string\">'bundle.js'</span>,\n    path: <span class=\"hljs-string\">'dist'</span>\n  },\n  plugins: [\n    <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({ title: <span class=\"hljs-string\">'Tree-shaking'</span> })\n  ]\n}\n</code></pre><p>This file provides webpack with the same information we gave to the CLI earlier. We&#39;ve defined <code>index.js</code> as our <code>entry</code> file and <code>bundle.js</code> as our <code>output</code> file. We&#39;ve also added our <code>html-webpack-plugin</code> which will generate an html file in our <code>dist</code> directory. Convenient.</p>\n<p>Go ahead and test this to make sure it&#39;s still working. Remove your <code>dist</code> directory, and in the command line type:</p>\n<pre><code><span class=\"hljs-attribute\">webpack</span>\n</code></pre><p>If everything went smoothly, you can open up <code>dist/index.html</code> and see &quot;Hello World!&quot;.</p>\n<p>==<strong>Note:</strong> The use of a configuration file gives us the convenience of typing <code>webpack</code> instead of <code>node_modules/.bin/webpack</code>. Small wins.==</p>\n<h4 id=\"step-5-babel\">Step 5: Babel</h4>\n<p>I mentioned earlier that webpack 2 brings native support for ES6 modules. This is all true, but it doesn&#39;t change the fact that ES6 is not fully supported across all browsers. Because of this, we&#39;re required to <em>transform</em> our ES6 code into readily acceptable JavaScript using a tool like <a href=\"http://babeljs.io/\">Babel</a>. In conjunction with webpack, Babel gives us the ability to write our &quot;future JavaScript&quot; without worrying about the implications of unsupported browsers.</p>\n<p>Let&#39;s go ahead and install Babel in our project:</p>\n<pre><code><span class=\"hljs-symbol\">npm</span> i --save-dev <span class=\"hljs-keyword\">babel-core </span><span class=\"hljs-keyword\">babel-loader </span><span class=\"hljs-keyword\">babel-preset-es2015</span>\n</code></pre><p>Take note of the <code>babel-preset-es2015</code> package. This little guy is the reason I sat down to write all of this up.</p>\n<h4 id=\"step-6-babel-loader-\">Step 6: <code>babel-loader</code></h4>\n<p>Webpack can be configured to transform specific files into modules via <a href=\"https://webpack.js.org/concepts/#loaders\">loaders</a>. Once they are transformed, they are added to a dependency graph. Webpack uses the graph to resolve dependencies and includes only what is needed into the final bundle. This is the basis for how webpack works. </p>\n<p>We can now configure webpack to use <code>babel-loader</code> to transform all of our <code>.js</code> files:</p>\n<pre><code><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'html-webpack-plugin'</span>);\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  entry: <span class=\"hljs-string\">'./src/index.js'</span>,\n  output: { filename: <span class=\"hljs-string\">'bundle.js'</span>, path: <span class=\"hljs-string\">'dist'</span> },\n  <span class=\"hljs-keyword\">module</span>: {\n    rules: [\n      {\n        test: <span class=\"hljs-regexp\">/\\.js$/</span>,\n        exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n        loader: <span class=\"hljs-string\">'babel-loader'</span>,\n        options: { \n          presets: [ \n            <span class=\"hljs-string\">'es2015'</span> \n          ] \n        }\n      }\n    ]\n  },\n  plugins: [ \n    <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({ title: <span class=\"hljs-string\">'Tree-shaking'</span> }) \n  ]\n};\n</code></pre><p>The <code>module</code> property provides a set of instructions for webpack. It says, &quot;take any files ending in <code>.js</code> and transform them using <code>babel-loader</code>, but don&#39;t transform any files inside of <code>node_modules</code>!&quot; </p>\n<p>We&#39;re also passing the <code>babel-preset-es2015</code> package as an option to <code>babel-loader</code>. This just tells <code>babel-loader</code> <em>how</em> to transform the JavaScript.</p>\n<p>Run <code>webpack</code> again to make sure everything is good. Yes? Great! What we&#39;ve done is bundled up our JavaScript files while compiling them down to JavaScript thats readily supported across browsers. </p>\n<h2 id=\"the-underlying-problem\">The underlying problem</h2>\n<p>The package <code>babel-preset-es2015</code> contains another package named <code>babel-plugin-transform-es2015-modules-commonjs</code> that turns all of our ES6 modules into <code>CommonJS</code> modules. This isn&#39;t ideal, and here&#39;s why.</p>\n<p>Javascript bundlers such as webpack and Rollup can only perform tree-shaking on modules that have a static structure. If a module is static, then the bundler can determine its structure at build time, safely removing code that isn&#39;t being imported anywhere. </p>\n<p><code>CommonJS</code> modules do not have a static structure. Because of this, webpack won’t be able to tree-shake unused code from the final bundle. Luckily, Babel has alleviated this issue by providing developers with an option that we can pass to our <code>presets</code> array along with <code>babel-preset-es2015</code>:</p>\n<pre><code><span class=\"hljs-selector-tag\">options</span>: { \n  <span class=\"hljs-attribute\">presets</span>: [ \n    [ <span class=\"hljs-string\">'es2015'</span>, { modules: false } ] \n  ]         \n}\n</code></pre><p>According to Babel&#39;s <a href=\"https://github.com/babel/babel/tree/master/packages/babel-preset-es2015#options\">documentation</a>: </p>\n<p><em>&quot;<code>modules</code> - Enable transformation of ES6 module syntax to another module type (Enabled by default to &quot;commonjs&quot;).\nCan be <code>false</code> to not transform modules, or one of <code>[&quot;amd&quot;, &quot;umd&quot;, &quot;systemjs&quot;, &quot;commonjs&quot;]</code>&quot;</em>.</p>\n<p>Slide that extra bit of code into your configuration and you&#39;ll be cooking with peanut oil.</p>\n<p>The final state of <code>webpack.config.js</code> looks like this:</p>\n<pre><code><span class=\"hljs-comment\">// webpack.config.js</span>\n<span class=\"hljs-keyword\">const</span> HtmlWebpackPlugin = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'html-webpack-plugin'</span>);\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  entry: <span class=\"hljs-string\">'./src/index.js'</span>,\n  output: { filename: <span class=\"hljs-string\">'bundle.js'</span>, path: <span class=\"hljs-string\">'dist'</span> },\n  <span class=\"hljs-keyword\">module</span>: {\n    rules: [\n      {\n        test: <span class=\"hljs-regexp\">/\\.js$/</span>,\n        exclude: <span class=\"hljs-regexp\">/node_modules/</span>,\n        loader: <span class=\"hljs-string\">'babel-loader'</span>,\n        options: { \n          presets: [ \n            [ <span class=\"hljs-string\">'es2015'</span>, { modules: <span class=\"hljs-literal\">false</span> } ] \n          ] \n        }\n      }\n    ]\n  },\n  plugins: [ <span class=\"hljs-keyword\">new</span> HtmlWebpackPlugin({ title: <span class=\"hljs-string\">'Tree-shaking'</span> }) ]\n};\n</code></pre><h2 id=\"the-grand-finale\">The Grand Finale</h2>\n<p>Run <code>webpack</code> again and pop open your <code>bundle.js</code> file. You won&#39;t notice any difference. Before you go crazy, know this! It&#39;s ok. We&#39;ve been running webpack in development mode this whole time. Webpack knows that we have unused exports in our code. Even though it&#39;s included in the final bundle, <code>sayBye</code> will never make it to production. </p>\n<p>If you still don&#39;t believe me, run <code>webpack -p</code> in your terminal. The <code>-p</code> option stands for <em>production</em>. Webpack will perform a few extra performance optimizations, including minification, removing any unused code along the way. </p>\n<p>Open up <code>bundle.js</code>. Since it&#39;s minified, go ahead and search for <code>Hello</code>. It <em>should</em> be there. Search for <code>Bye</code>. It <em>shouldn&#39;t</em>. </p>\n<p>Voila! We now have a working implementation of tree-shaking in webpack 2!</p>\n<p>For the curious, I&#39;ve been slowly iterating over my own lightweight webpack configuration in a <a href=\"https://github.com/jake-wies/webpack-hotplate\">GitHub Repo</a>. It&#39;s not meant to be overly verbose and bloated. It&#39;s focused on being an approachable boilerplate with walkthroughs at every turn. If you&#39;re interested, check it out!</p>\n",
  "dir": "posts",
  "base": "tree-shaking-in-webpack-2.json",
  "ext": ".json",
  "sourceBase": "tree-shaking-in-webpack-2.md",
  "sourceExt": ".md"
}